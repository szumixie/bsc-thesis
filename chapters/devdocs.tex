\chapter{Developer documentation}\label{ch:devdocs}

\section{Project structure}

The project is implemented in Haskell~\cite{haskell2010}, using the
\emph{Glasgow Haskell Compiler} (\caps{GHC}) with many of its extensions
enabled~\cite{ghc}.

Stack~\cite{stack} is used to manage the project and its dependencies.

Project structure and algorithm ideas are from~\cite{elabzoo}.

~\cite{relude}

\Cref{fig:modules}

\begin{figure}
  \resizebox{\textwidth}{!}{\input{graphs/modules.tex}}
  \caption{Transitively reduced dependency graph of the Haskell modules
  }\label{fig:modules}
\end{figure}

\section{?}

~\cite{funcdata, optics, inotherwords, prettyprinter}

\section{Raw Syntax}
\Cref{lst:raw-adt}

\begin{listing}
  \begin{minted}{hs}
data Term
  = Span Span Term
  | Var Name
  | Hole
  | Let Name (Maybe Term) Term Term
  | Univ
  | Pi Plicity Name (Maybe Term) Term
  | Lam Plicity Name (Maybe Term) Term
  | App Plicity Term Term
  | RowType Term
  | RowEmpty
  | RowExt Label Term Term
  | RecordType Term
  | RecordEmpty
  | RecordExt Label (Maybe Term) Term Term
  | RecordProj Label Term
  | RecordRestr Label Term
  \end{minted}
  \caption{Raw syntax \caps{ADT}}\label{lst:raw-adt}
\end{listing}

\section{Core Syntax}
\Cref{lst:core-adt}

\begin{listing}
  \begin{minted}{hs}
data Term
  = Var Level
  | Meta Meta (Maybe BoundMask)
  | Let Name Term Term
  | Univ
  | Pi Plicity Name Term Term
  | Lam Plicity Name Term
  | App Plicity Term Term
  | RowType Term
  | RowLit (MultiMap Label Term)
  | RowExt (MultiMap Label Term) Term
  | RecordType Term
  | RecordLit (MultiMap Label Term)
  | RecordProj Label Int Term
  | RecordAlter (MultiMapAlter Label Term) Term
  \end{minted}
  \caption{Core syntax \textls{ADT}}\label{lst:core-adt}
\end{listing}

\section{Parsing}

The Haskell library Megaparsec~\cite{megaparsec} is used to do both lexing and
parsing at the same time. Megaparsec is a monadic parser combinator
library~\cite{parsing}.

\section{Evaluation}

\emph{Normalization-by-evaluation} (\caps{NBE}) with explicit closures is
implemented to evaluate lambda terms to normal form.

\section{Unification}

\section{Elaboration}

Bidirectional type-checking algorithm is used~\cite{deptypecheck, lambdapi}.

\section{Main}

~\cite{optparse}

\section{Testing}
