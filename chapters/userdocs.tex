\chapter{User documentation}\label{ch:userdocs}

Pirec is a dependently typed functional language with row polymorphism and
extensible records. It can be used to write programs without side effect and
prove simple theorems. The program is command line tool that can type check and
interpret Pirec programs.

\section{Installation}\label{sec:install}

\begin{enumerate}
  \item Install Stack~\cite{stack}.
  \item Clone or download the source code repository.
  \item Enter the repository and run the following:
        \begin{minted}{sh}
stack install --flag pirec:release
        \end{minted}
\end{enumerate}

\section{Usage}\label{sec:usage}

A Pirec program can be written into a file with any source code editor.

Comments in Pirec are similar to Haskell and its derived languages, with
both line comments and block comments.
\begin{minted}{pirec.py:PirecLexer -x}
-- This is a line comment
{- This is a
   block comment -}
\end{minted}

The identity function can be defined like so:
\begin{minted}{pirec.py:PirecLexer -x}
id = λ (A : Type) → λ (a : A) → a
\end{minted}
It can then be applied to for example an empty record:
\begin{minted}{pirec.py:PirecLexer -x}
id (Rec #{}) rec{}
\end{minted}
where \mintinline{pirec.py:PirecLexer -x}{Rec #{}} is the type of empty records
and \mintinline{pirec.py:PirecLexer -x}{rec{}} is an instance of an empty
record. These two lines can be put into a file, for example into
\texttt{id.pirec}, then run \mintinline{sh}{pirec id.pirec}. The
program will then output the following, prettyprinting the normal form of the
last line of the input and its inferred type:
\begin{minted}{pirec.py:PirecLexer -x}
rec{  }
  : Rec #{  }
\end{minted}

Here is another way to define the identity function:
\begin{minted}{pirec.py:PirecLexer -x}
id2 : ∀ (A : Type) → A → A = λ _ a → a
\end{minted}
The definition is given a type signature, the lambda binders are grouped
together with a single lambda and their types are removed since they are
optional, the unused lambda parameter is ignored with an underscore.

The first parameter can be made into an implicit parameter, and its type is also
optional:
\begin{minted}{pirec.py:PirecLexer -x}
id3 : ∀ {A} → A → A = λ a → a
\end{minted}
With this, the type of the argument does not need to be written out:
\begin{minted}{pirec.py:PirecLexer -x}
id3 rec{}
\end{minted}

Data types can be defined with their Church encoding, for example Booleans:
\begin{minted}{pirec.py:PirecLexer -x}
Bool  : Type = ∀ {A} → A → A → A
true  : Bool = λ x y → x
false : Bool = λ x y → y
\end{minted}

\section{Errors}

\section{Lexical structure}

Pirec is indentation sensitive, similarly to Haskell.

\begin{table}
  \centering
  \begin{tabular}{@{}cc@{}}
    \toprule
    Unicode & \caps{ASCII} \\\midrule
    \mintinline{pirec.py:PirecLexer -x}{→}
            &
    \mintinline{pirec.py:PirecLexer -x}{->}
    \\
    \mintinline{pirec.py:PirecLexer -x}{∀}
            &
    \mintinline{pirec.py:PirecLexer -x}{forall}
    \\
    \mintinline{pirec.py:PirecLexer -x}{λ}
            &
    \mintinline{pirec.py:PirecLexer -x}{\ }
    \\\bottomrule
  \end{tabular}
  \caption{\caps{ASCII} alternatives to Unicode syntax}\label{tab:ascii}
\end{table}

\section{Syntax}

\begin{minted}{ebnf}
atom = identifier | "_"
\end{minted}

\begin{figure}
  \begin{align*}
    \Let \{ x_1 = t_1;\ \dots;\ x_n = t_n;\ u \}
     & \quad\mapsto\quad
    \Let \{ x_1 = t_1;\ \dots \Let \{ x_n = t_n;\ u \} \dots \}
    \\
    \forall (x_1 : A_1) \dots (x_n : A_n) \to B
     & \quad\mapsto\quad
    \forall (x_1 : A_1) \to \dots \forall (x_n : A_n) \to B
    \\
    \lambda x_1 \dots x_n \to B
     & \quad\mapsto\quad
    \lambda x_1 \to \dots \lambda x_n \to B
    \\
    \# \{ l_1 : t_1;\ \dots;\ l_n : t_n \}
     & \quad\mapsto\quad
    \# \{ l_1 : t_1 \mid \dots \# \{ l_n : t_n \mid \# \{ \} \} \dots \}
    \\
    \# \{ l_1 : t_1;\ \dots;\ l_n : t_n \mid r \}
     & \quad\mapsto\quad
    \# \{ l_1 : t_1 \mid \dots \# \{ l_n : t_n \mid r \} \dots \}
    \\
    \RecordLit \{ l_1 = t_1;\ \dots;\ l_n = t_n \}
     & \quad\mapsto\quad
    \RecordLit \{ l_1 = t_1 \mid \dots
    \RecordLit \{ l_n = t_n \mid \RecordLit \{ \} \} \dots \}
    \\
    \RecordLit \{ l_1 = t_1;\ \dots;\ l_n = t_n \mid u \}
     & \quad\mapsto\quad
    \RecordLit \{ l_1 = t_1 \mid \dots
    \RecordLit \{ l_n = t_n \mid u \} \dots \}
    \\
    \RecordLit \{ l_1 \coleqq t_1;\ \dots;\ l_n \coleqq t_n \mid u \}
     & \quad\mapsto\quad
    \RecordLit \{ l_1 \coleqq t_1 \mid \dots
    \RecordLit \{ l_n \coleqq t_n \mid u \RecordRestr l_n \}
    \dots \RecordRestr l_1 \}
  \end{align*}
  \caption{Syntactic sugar in Pirec}\label{fig:sugar}
\end{figure}

\begin{figure}
  \begin{alignat*}{2}
    t, u, v, w, r, A, B, R \Coleqq{}
     & x
     & \qquad\text{variable}
    \\
    \mid{}
     & \_
     & \qquad\text{hole}
    \\
    \mid{}
     & {\Let \{ x = t;\ u \}}
     & \qquad\text{let expression}
    \\
    \mid{}
     & {\Univ}
     & \qquad\text{universe}
    \\
    \mid{}
     & \forall (x : A) \to B
     & \qquad\text{dependent function}
    \\
    \mid{}
     & \lambda x \to t
     & \qquad\text{lambda abstraction}
    \\
    \mid{}
     & t\ u
     & \qquad\text{function application}
    \\
    \mid{}
     & {\RowType A}
     & \qquad\text{row type}
    \\
    \mid{}
     & \# \{ \}
     & \qquad\text{empty row}
    \\
    \mid{}
     & \# \{ l : t \mid r \}
     & \qquad\text{row extension}
    \\
    \mid{}
     & {\RecordType R}
     & \qquad\text{record type}
    \\
    \mid{}
     & {\RecordLit \{ \}}
     & \qquad\text{empty record}
    \\
    \mid{}
     & {\RecordLit \{ l = t \mid u \}}
     & \qquad\text{record extension}
    \\
    \mid{}
     & t.l
     & \qquad\text{record projection}
    \\
    \mid{}
     & t \RecordRestr l
     & \qquad\text{record restriction}
  \end{alignat*}
  \caption{The desugared terms of Pirec}\label{fig:term}
\end{figure}

\section{Type system}

The typing rules of Pirec are presented in \cref{fig:typing} without implicit
arguments.

~\cite{scopedlabels}

\begin{figure}
  \begin{gather*}
    \begin{prooftree}
      \infer0{\Gamma,\ x : A \vdash x : A}
    \end{prooftree}
    \qquad
    \begin{prooftree}
      \hypo{\Gamma \vdash t : A}
      \hypo{\Gamma \vdash u : B[x \coleqq t]}
      \infer2{\Gamma
        \vdash \Let \{ x = t;\ u \} : B}
    \end{prooftree}
    \\
    \begin{prooftree}
      \infer0{\Gamma \vdash \Univ : \Univ}
    \end{prooftree}
    \qquad
    \begin{prooftree}
      \hypo{\Gamma \vdash A : \Univ}
      \hypo{\Gamma,\ x : A \vdash B : \Univ}
      \infer2{\Gamma \vdash \forall (x : A) \to B : \Univ}
    \end{prooftree}
    \\
    \begin{prooftree}
      \hypo{\Gamma,\ x : A \vdash t : B}
      \infer1{\Gamma \vdash \lambda x \to t : \forall (x : A) \to B}
    \end{prooftree}
    \qquad
    \begin{prooftree}
      \hypo{\Gamma \vdash t : \forall (x : A) \to B}
      \hypo{\Gamma \vdash u : A}
      \infer2{\Gamma \vdash t\ u : B[x \coleqq u]}
    \end{prooftree}
    \\
    \begin{prooftree}
      \hypo{\Gamma \vdash A : \Univ}
      \infer1{\Gamma \vdash \RowType A : \Univ}
    \end{prooftree}
    \qquad
    \begin{prooftree}
      \infer0{\Gamma \vdash \# \{ \} : \RowType A}
    \end{prooftree}
    \qquad
    \begin{prooftree}
      \hypo{\Gamma \vdash t : A}
      \hypo{\Gamma \vdash r : \RowType A}
      \infer2{\Gamma \vdash \# \{ l : t \mid r \} : \RowType A}
    \end{prooftree}
    \\
    \begin{prooftree}
      \hypo{\Gamma \vdash R : \RowType \Univ}
      \infer1{\Gamma \vdash \RecordType R : \Univ}
    \end{prooftree}
    \qquad
    \begin{prooftree}
      \infer0{\Gamma \vdash \RecordLit \{ \} : \RecordType \# \{ \}}
    \end{prooftree}
    \qquad
    \begin{prooftree}
      \hypo{\Gamma \vdash t : A}
      \hypo{\Gamma \vdash u : \RecordType R}
      \infer2{\Gamma \vdash \RecordLit \{ l = t \mid u \}
        : \RecordType \# \{ l : A \mid R \}}
    \end{prooftree}
    \\
    \begin{prooftree}
      \hypo{\Gamma \vdash t : \RecordType \# \{ l : A \mid R \}}
      \infer1{\Gamma \vdash t.l : A}
    \end{prooftree}
    \qquad
    \begin{prooftree}
      \hypo{\Gamma \vdash t : \RecordType \# \{ l : A \mid R \}}
      \infer1{\Gamma \vdash t \RecordRestr l : \RecordType R}
    \end{prooftree}
  \end{gather*}
  \caption{The typing rules of Pirec}\label{fig:typing}
\end{figure}

\section{Semantics}
\Cref{fig:big-step}

\begin{figure}
  \begin{alignat*}{2}
    n \Coleqq{} & x
                & \qquad\text{variable}             \\
    \mid{}      & n\ t
                & \qquad\text{function application} \\
    \mid{}      & \# \{ l : t \mid n \}
                & \qquad\text{row extension}        \\
    \mid{}      & {\RecordLit \{ l = t \mid n \}}
                & \qquad\text{record extension}     \\
    \mid{}      & n.l
                & \qquad\text{record projection}    \\
    \mid{}      & n \RecordRestr l
                & \qquad\text{record restriction}
  \end{alignat*}
  \caption{The neutral terms of Pirec}\label{fig:neutral}
\end{figure}

\begin{figure}
  \begin{gather*}
    \begin{prooftree}
      \infer0{x \Downarrow x}
    \end{prooftree}
    \qquad
    \begin{prooftree}
      \hypo{u[x \coleqq t] \Downarrow u'}
      \infer1{\Let \{ x = t;\ u \} \Downarrow u'}
    \end{prooftree}
    \\
    \begin{prooftree}
      \infer0{\Univ \Downarrow \Univ}
    \end{prooftree}
    \qquad
    \begin{prooftree}
      \hypo{A \Downarrow A'}
      \hypo{B \Downarrow B'}
      \infer2{\forall (x : A) \to B \Downarrow \forall (x : A') \to B'}
    \end{prooftree}
    \\
    \begin{prooftree}
      \hypo{t \Downarrow t'}
      \infer1{\lambda x \to t \Downarrow \lambda x \to t'}
    \end{prooftree}
    \qquad
    \begin{prooftree}
      \hypo{t \Downarrow \lambda x \to v}
      \hypo{v[x \coleqq u] \Downarrow v'}
      \infer2{t\ u \Downarrow v'}
    \end{prooftree}
    \qquad
    \begin{prooftree}
      \hypo{t \Downarrow n}
      \hypo{u \Downarrow u'}
      \infer2{t\ u \Downarrow n\ u'}
    \end{prooftree}
    \\
    \begin{prooftree}
      \hypo{A \Downarrow A'}
      \infer1{\RowType A \Downarrow \RowType A'}
    \end{prooftree}
    \qquad
    \begin{prooftree}
      \infer0{\# \{ \} \Downarrow \# \{ \}}
    \end{prooftree}
    \qquad
    \begin{prooftree}
      \hypo{t \Downarrow t'}
      \hypo{r \Downarrow r'}
      \infer2{\# \{ l : t \mid r \} \Downarrow \# \{ l : t' \mid r' \}}
    \end{prooftree}
    \\
    \begin{prooftree}
      \hypo{R \Downarrow R'}
      \infer1{\RecordType R \Downarrow \RecordType R'}
    \end{prooftree}
    \qquad
    \begin{prooftree}
      \infer0{\RecordLit \{ \} \Downarrow \RecordLit \{ \}}
    \end{prooftree}
    \qquad
    \begin{prooftree}
      \hypo{t \Downarrow t'}
      \hypo{u \Downarrow u'}
      \infer2{\RecordLit \{ l = t \mid u \}
        \Downarrow \RecordLit \{ l = t' \mid u' \}}
    \end{prooftree}
    \\
    \begin{prooftree}
      \hypo{t \Downarrow \RecordLit \{ l = u \mid v \}}
      \infer1{t.l \Downarrow u}
    \end{prooftree}
    \qquad
    \begin{prooftree}
      \hypo{t \Downarrow \RecordLit \{ l' = u \mid v \}}
      \hypo{l \neq l'}
      \hypo{v.l \Downarrow w}
      \infer3{t.l \Downarrow w}
    \end{prooftree}
    \qquad
    \begin{prooftree}
      \hypo{t \Downarrow n}
      \infer1{t.l \Downarrow n.l}
    \end{prooftree}
    \\
    \begin{prooftree}
      \hypo{t \Downarrow \RecordLit \{ l = u \mid v \}}
      \infer1{t \RecordRestr l \Downarrow v}
    \end{prooftree}
    \qquad
    \begin{prooftree}
      \hypo{t \Downarrow \RecordLit \{ l' = u \mid v \}}
      \hypo{l \neq l'}
      \hypo{v \RecordRestr l \Downarrow v'}
      \infer3{t \RecordRestr l \Downarrow \RecordLit \{ l' = u \mid v' \}}
    \end{prooftree}
    \qquad
    \begin{prooftree}
      \hypo{t \Downarrow n}
      \infer1{t \RecordRestr l \Downarrow n \RecordRestr l}
    \end{prooftree}
  \end{gather*}
  \caption{The big-step operational semantics of Pirec}\label{fig:big-step}
\end{figure}
